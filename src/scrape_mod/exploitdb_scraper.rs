use crate::db_api;
use crate::db_api::consts::{EXPLOITDB_COLUMN, EXPLOITDB_TABLE, ID};
use crate::db_api::db_connection::get_db_connection;
use crate::db_api::delete::remove_entries_id;
use crate::db_api::insert::insert_parallel;
use crate::db_api::query_db::count_table_entries;
use crate::scrape_mod::consts;
use crate::scrape_mod::consts::{
    FILE_EXPLOIT_LOCATION, NEW_FILE_EXPLOIT, SEARCHSPLOIT_FILE_LOCATION, USER_PASSWORD,
};
use crate::scrape_mod::structs::ExploitDB;
use csv::ReaderBuilder;
use sqlx::{Pool, Postgres};
use std::collections::HashSet;
use std::error::Error;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::time::Instant;
use std::{env, fs, io};

/// Reads a CSV file and returns a vector of `ExploitDB` records.
/// If `update` is set to `true`, it compares `file_path` against `file_new_path`
/// and returns only the new or updated entries.
///
/// # Arguments
///
/// * `file_path` - Path to the existing CSV file.
/// * `file_new_path` - Path to the new CSV file for comparison.
/// * `update` - Boolean flag indicating whether to check for updates.
///
/// # Returns
///
/// * `Ok(Vec<ExploitDB>)` - A vector containing updated or new entries.
/// * `Err(Box<dyn Error>)` - An error if file reading or deserialization fails.
///
/// # Example
/// ```
/// let records = read_csv("exploits.csv", "exploits_new.csv", &true)?;
/// println!("Updated records: {:?}", records);
/// ```
pub fn read_csv(
    file_path: &str,
    file_new_path: &str,
    update: &bool,
) -> Result<Vec<ExploitDB>, Box<dyn Error>> {
    if *update {
        // Read both existing and new files
        let existing_records = read_csv_internal(file_path)?;
        let new_records = read_csv_internal(file_new_path)?;

        // Convert records into hash sets for comparison
        let existing_set: HashSet<ExploitDB> = existing_records.into_iter().collect();
        let new_set: HashSet<ExploitDB> = new_records.into_iter().collect();

        // Find new or changed entries
        let updated_or_new_entries: Vec<ExploitDB> = new_set
            .difference(&existing_set)
            .cloned() // Cloning because .difference() yields references
            .collect();

        return Ok(updated_or_new_entries);
    }

    // Read the file normally if update flag is not set
    read_csv_internal(file_path)
}

/// Helper function to read a CSV file and deserialize it into a vector of `ExploitDB`.
fn read_csv_internal(file_path: &str) -> Result<Vec<ExploitDB>, Box<dyn Error>> {
    let file = File::open(file_path)?;
    let mut rdr = ReaderBuilder::new().has_headers(true).from_reader(file);

    let mut entries = Vec::new();
    for result in rdr.deserialize() {
        let record: ExploitDB = result?;
        entries.push(record);
    }

    Ok(entries)
}

/// Copies a specified file to the `src/resources` directory in the current working directory.
/// If the destination file already exists and the `update` flag is set to `true`,
/// the new file will be copied with a `_new.csv` suffix.
///
/// # Arguments
///
/// * `source` - A string slice that holds the path to the source file.
/// * `update` - A boolean flag indicating whether to overwrite or create a new file.
///
/// # Returns
///
/// * `Ok(PathBuf)` - The destination path where the file was copied.
/// * `Err(io::Error)` - An error if the file cannot be copied or the path is invalid.
///
/// # Errors
///
/// This function will return an error in the following cases:
/// - If the source file path is invalid or does not contain a file name.
/// - If the `src/resources` directory does not exist and cannot be created.
/// - If the file copying operation fails.
///
/// # Example
///
/// ```
/// let result = copy_to_current_dir("path/to/file.txt", &false);
/// match result {
///     Ok(destination) => println!("File copied to: {:?}", destination),
///     Err(e) => eprintln!("Error copying file: {}", e),
/// }
/// ```
fn copy_to_current_dir(source: &str, update: &bool) -> Result<PathBuf, io::Error> {
    let current_dir = env::current_dir()?;
    let resources_path = current_dir.join("src/resources");
    log::info!("Resources path: {:?}", resources_path);

    // Ensure the destination directory exists
    if !resources_path.exists() {
        fs::create_dir_all(&resources_path)?;
    }

    let mut destination = Path::new(FILE_EXPLOIT_LOCATION);

    if destination.exists() {
        if *update {
            log::info!("File already exists. Copying to a new filename.");
            // Generate a new filename with `_new.csv` suffix
            destination = Path::new(NEW_FILE_EXPLOIT);
        } else {
            log::info!("File already exists. Updating existing file.");
        }
    }

    fs::copy(source, &destination)?;
    log::info!("File copied to: {:?}", destination);

    Ok(PathBuf::from(destination))
}

/// Handles the process of copying an exploit database CSV file and inserting its contents into a database.
///
/// This function performs the following steps:
/// 1. Copies the exploit database file to the current working directory.
/// 2. Reads the CSV file to extract exploit records.
/// 3. Establishes a database connection.
/// 4. Inserts the records into the database.
///
/// # Returns
///
/// * `Ok(())` if all operations complete successfully.
/// * `Err(Box<dyn Error>)` if any step fails, such as file copying, reading, or database insertion.
///
/// # Errors
///
/// This function will return an error if:
/// - The file cannot be copied to the working directory.
/// - The exploit CSV file cannot be read or parsed.
/// - The database connection cannot be established.
/// - The data insertion into the database fails.
///
/// # Example
///
/// ```
/// match exploitdb_2_database().await {
///     Ok(_) => println!("Exploit database updated successfully"),
///     Err(e) => eprintln!("Error updating exploit database: {}", e),
/// }
/// ```
pub async fn exploitdb_2_database() -> Result<(), Box<dyn Error>> {
    match update_searchsploit() {
        Ok(_) => {}
        Err(e) => {
            log::error!("Failed to update searchsploit {}", e);
        }
    };

    let mut update = false;

    if count_table_entries(EXPLOITDB_TABLE).await > 0 {
        update = true;
    }
    log::info!("Exploring tables {}", update);

    match copy_to_current_dir(SEARCHSPLOIT_FILE_LOCATION, &update) {
        Ok(_) => log::info!("File copied to the current directory successfully!"),
        Err(e) => log::error!("Failed to copy file: {}", e),
    };

    let exploits = match read_csv(FILE_EXPLOIT_LOCATION, NEW_FILE_EXPLOIT, &update) {
        Ok(exploits) => exploits,
        Err(e) => {
            log::error!("Could not load exploit file: {}", e);
            return Err(format!("Could not load exploit file: {}", e).into());
        }
    };

    log::info!("Number of exploits: {}", exploits.len());

    let db_connection = match get_db_connection().await {
        Ok(db_connection) => db_connection,
        Err(_) => {
            log::error!("No connection available to ExploitDB");
            return Ok(());
        }
    };

    if update {
        remove_entries_id(
            &db_connection,
            EXPLOITDB_TABLE,
            EXPLOITDB_COLUMN,
            ID,
            &exploits,
        )
        .await?;
    }

    match insert_parallel(&db_connection, EXPLOITDB_TABLE, EXPLOITDB_COLUMN, &exploits).await {
        Ok(_) => log::info!("Exploit database inserted successfully"),
        Err(e) => {
            log::error!("Could not insert exploit database: {}", e);
            return Ok(());
        }
    };
    if update{
        match fs::remove_file(FILE_EXPLOIT_LOCATION) {
            Ok(_) => println!("File removed successfully."),
            Err(e) => eprintln!("Failed to remove file: {}", e),
        }
        match fs::rename(NEW_FILE_EXPLOIT, FILE_EXPLOIT_LOCATION) {
            Ok(_) => println!("File moved successfully."),
            Err(e) => eprintln!("Failed to move file: {}", e),
        }

    }

    Ok(())
}

/// Updates the searchsploit database by running the `searchsploit -u` command with sudo privileges.
///
/// This function spawns a child process to execute the update command, passing the user's password
/// securely to stdin.
///
/// # Returns
///
/// * `Ok(())` - If the command executes successfully.
/// * `Err(Box<dyn Error>)` - If an error occurs during execution.
///
/// # Errors
///
/// This function will return an error if:
/// - The command fails to spawn.
/// - Writing the password to stdin fails.
/// - The command execution results in a non-zero exit status.
///
/// # Security Considerations
///
/// - Avoid storing plaintext passwords in the source code. Instead, use environment variables or
/// secure input methods such as the `rpassword` crate.
///
/// # Example
///
/// ```no_run
/// if let Err(e) = update_searchsploit() {
///     eprintln!("Error updating searchsploit: {}", e);
/// }
/// ```
fn update_searchsploit() -> Result<(), Box<dyn Error>> {
    let mut child = Command::new("sudo")
        .arg("-S") // Allow reading password from stdin
        .arg("searchsploit")
        .arg("-u")
        .stdin(Stdio::piped())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()
        .map_err(|e| format!("Failed to execute searchsploit command: {}", e))?;

    if let Some(mut stdin) = child.stdin.take() {
        stdin
            .write_all(format!("{}\n", USER_PASSWORD).as_bytes())
            .map_err(|e| {
                log::error!("Could not write to stdin: {}", e);
                e
            })?;
    } else {
        return Err("Failed to obtain stdin for the subprocess".into());
    }

    let status = child
        .wait()
        .map_err(|e| format!("Failed to wait on child process: {}", e))?;

    if !status.success() && status.code() != Some(6) {
        return Err(format!("Searchsploit update command failed with status: {}", status).into());
    }

    log::info!("Searchsploit updated successfully.");
    Ok(())
}
