use crate::scrape_mod::structs::ExploitDB;
use csv::ReaderBuilder;
use std::error::Error;
use std::fs::File;
use std::path::PathBuf;
use std::{env, fs, io};
use std::io::Write;
use std::process::{Command, Stdio};
use std::time::Instant;
use sqlx::{Pool, Postgres};
use crate::db_api;
use crate::db_api::consts::{EXPLOITDB_COLUMN, EXPLOITDB_TABLE};
use crate::db_api::db_connection::get_db_connection;
use crate::db_api::insert::insert_parallel;
use crate::scrape_mod::consts;
use crate::scrape_mod::consts::{SEARCHSPLOIT_FILE_LOCATION, USER_PASSWORD};

/// Reads a CSV file and deserializes it into a vector of `ExploitDB` structs.
///
/// # Parameters
/// - `file_path`: The path to the CSV file.
///
/// # Returns
/// - `Ok(Vec<ExploitDB>)`: A vector of `ExploitDB` objects if the file is successfully read and parsed.
/// - `Err(Box<dyn Error>)`: An error if the file cannot be read or parsed.
///
/// # Example
/// ```no_run
/// use log::{error, info};
/// let file_path = "exploitdb.csv";
/// match read_csv(file_path) {
///     Ok(data) => info!("Successfully read {} entries.", data.len()),
///     Err(e) => error!("Error reading CSV: {}", e),
/// }
/// ```
pub fn read_csv(file_path: &str) -> Result<Vec<ExploitDB>, Box<dyn Error>> {
    // Open the CSV file
    let file = File::open(file_path)?;

    // Create a CSV reader
    let mut rdr = ReaderBuilder::new()
        .has_headers(true) // Assumes the CSV file has headers
        .from_reader(file);

    // Deserialize each record into an ExploitDB struct
    let mut records = Vec::new();
    for result in rdr.deserialize() {
        let record: ExploitDB = result?;
        records.push(record);
    }

    Ok(records)
}


/// Copies a specified file to the `src/resources` directory in the current working directory.
///
/// # Arguments
///
/// * `source` - A string slice that holds the path to the source file.
///
/// # Returns
///
/// * `Ok(PathBuf)` - The destination path where the file was copied.
/// * `Err(io::Error)` - An error if the file cannot be copied or the path is invalid.
///
/// # Errors
///
/// This function will return an error in the following cases:
/// - If the source file path is invalid or does not contain a file name.
/// - If the `src/resources` directory does not exist and cannot be created.
/// - If the file copying operation fails.
///
/// # Example
///
/// ```
/// let result = copy_to_current_dir("path/to/file.txt");
/// match result {
///     Ok(destination) => println!("File copied to: {:?}", destination),
///     Err(e) => eprintln!("Error copying file: {}", e),
/// }
/// ```
fn copy_to_current_dir(source: &str) -> Result<PathBuf, io::Error> {
    let current_dir = env::current_dir()?;
    let resources_path = current_dir.join("src/resources");
    log::info!("Resources path: {:?}", resources_path);

    if !resources_path.exists() {
        fs::create_dir_all(&resources_path)?;
    }

    let binding = PathBuf::from(source);
    let file_name = binding
        .file_name()
        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidInput, "Invalid source file path"))?;

    let destination = resources_path.join(file_name);
    fs::copy(source, &destination)?;

    Ok(destination)
}

/// Handles the process of copying an exploit database CSV file and inserting its contents into a database.
///
/// This function performs the following steps:
/// 1. Copies the exploit database file to the current working directory.
/// 2. Reads the CSV file to extract exploit records.
/// 3. Establishes a database connection.
/// 4. Inserts the records into the database.
///
/// # Returns
///
/// * `Ok(())` if all operations complete successfully.
/// * `Err(Box<dyn Error>)` if any step fails, such as file copying, reading, or database insertion.
///
/// # Errors
///
/// This function will return an error if:
/// - The file cannot be copied to the working directory.
/// - The exploit CSV file cannot be read or parsed.
/// - The database connection cannot be established.
/// - The data insertion into the database fails.
///
/// # Example
///
/// ```
/// match exploitdb_2_database().await {
///     Ok(_) => println!("Exploit database updated successfully"),
///     Err(e) => eprintln!("Error updating exploit database: {}", e),
/// }
/// ```
pub async fn exploitdb_2_database() -> Result<(), Box<dyn Error>> {
    match update_searchsploit() {
        Ok(_) => {}
        Err(_) => {log::error!("Failed to update searchsploit");}
    };

    match copy_to_current_dir(SEARCHSPLOIT_FILE_LOCATION) {
        Ok(_) => log::info!("File copied to the current directory successfully!"),
        Err(e) => log::error!("Failed to copy file: {}", e),
    };

    let exploits = match read_csv(consts::FILE_EXPLOIT_LOCATION) {
        Ok(exploits) => exploits,
        Err(e) => {
            log::error!("Could not load exploit file: {}", e);
            return Err(format!("Could not load exploit file: {}", e).into());;

        }
    };

    log::info!("Number of exploits: {}", exploits.len());

    let db_connection = match get_db_connection().await {
        Ok(db_connection) => db_connection,
        Err(_) => {
            log::error!("No connection available to ExploitDB");
            return Ok(());  // Consider propagating the error instead
        }
    };

    match insert_parallel(&db_connection, EXPLOITDB_TABLE, EXPLOITDB_COLUMN, &exploits).await {
        Ok(_) => log::info!("Exploit database inserted successfully"),
        Err(e) => {
            log::error!("Could not insert exploit database: {}", e);
            return Ok(());
        }
    };

    Ok(())
}


/// Updates the searchsploit database by running the `searchsploit -u` command with sudo privileges.
///
/// This function spawns a child process to execute the update command, passing the user's password
/// securely to stdin.
///
/// # Returns
///
/// * `Ok(())` - If the command executes successfully.
/// * `Err(Box<dyn Error>)` - If an error occurs during execution.
///
/// # Errors
///
/// This function will return an error if:
/// - The command fails to spawn.
/// - Writing the password to stdin fails.
/// - The command execution results in a non-zero exit status.
///
/// # Security Considerations
///
/// - Avoid storing plaintext passwords in the source code. Instead, use environment variables or
/// secure input methods such as the `rpassword` crate.
///
/// # Example
///
/// ```no_run
/// if let Err(e) = update_searchsploit() {
///     eprintln!("Error updating searchsploit: {}", e);
/// }
/// ```
fn update_searchsploit() -> Result<(), Box<dyn Error>> {
    let mut child = Command::new("sudo")
        .arg("-S")  // Allow reading password from stdin
        .arg("searchsploit")
        .arg("-u")
        .stdin(Stdio::piped())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()
        .map_err(|e| format!("Failed to execute searchsploit command: {}", e))?;

    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(format!("{}\n", USER_PASSWORD).as_bytes())
            .map_err(|e| {
                log::error!("Could not write to stdin: {}", e);
                e
            })?;
    } else {
        return Err("Failed to obtain stdin for the subprocess".into());
    }

    let status = child.wait()
        .map_err(|e| format!("Failed to wait on child process: {}", e))?;

    if !status.success() {
        return Err(format!("Searchsploit update command failed with status: {}", status).into());
    }

    log::info!("Searchsploit updated successfully.");
    Ok(())
}
